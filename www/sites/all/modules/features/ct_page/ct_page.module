<?php
/**
 * @file
 * Code for the Page feature.
 */

include_once('ct_page.features.inc');

function ct_page_block_info() {
  $blocks['lc_section_nav'] = array(
    'info' => t('LC Section Nav'),
    'cache' => DRUPAL_NO_CACHE,
  );

  return $blocks;
}

function ct_page_block_view($delta) {
  $block = array();

  switch ($delta) {
    case 'lc_section_nav':
      $block = ct_page_lc_section_nav();
      break;
  }

  return $block;
}

function ct_page_lc_section_nav() {
  $start = microtime(TRUE);
  $display_block = FALSE;
  // Get current node.
  $node = menu_get_object();
  $cache_nids = array($node->nid);
  $trail = array('node/' . $node->nid);

  // Retrieve block from cache if available.
  if ($block = cache_get('ct_page:nav:' . $node->nid, 'cache_block')) {
    return $block->data;
  }

  // We want to display this block if the current node has parents or children.
  if (isset($node->field_parents[$node->language])) {
    if (count($node->field_parents[$node->language])) {
      $display_block = TRUE;
    }
  }
  if (isset($node->field_children[$node->language])) {
    if (count($node->field_children[$node->language])) {
      $display_block = TRUE;
    }
  }

  if ($display_block) {
    // First, find the top-level parent.
    $parent_found = FALSE;
    while (!$parent_found) {
      if (isset($parent_nid)) {
        $node = node_load($parent_nid);
      }
      if (isset($node->field_parents[$node->language])) {
        if (count($node->field_parents[$node->language]) > 0) {
          // Only handling one parent for now.
          $parent_nid = $node->field_parents[$node->language][0]['nid'];
        }
        else {
          $parent_found = TRUE;
        }
      }
      else {
        $parent_found = TRUE;
      }
    }

    $block = array(
      'subject' => l($node->title, 'node/' . $node->nid),
    );

    // Set up the menu array.
    $items = array();

    // Now that we've found the parent, work from the top down.
    if (isset($node->field_children[$node->language])) {
      if (count($node->field_children[$node->language])) {
        $cache_nids[] = $node->nid;
        foreach ($node->field_children[$node->language] as $child) {
          // Recursively generate this part of the tree.
          $node = node_load($child['nid']);
          $cache_nids[] = $node->nid;
          $item = array(
            'link' => array(
              'title' => $node->title,
              'href' => 'node/' . $node->nid,
              'expanded' => 0,
            ),
            'below' => array(),
          );
          _ct_page_generate_child_leaf($node, $item['below']);
          if (count($item['below'])) {
            $item['link']['has_children'] = 1;
          }
          else {
            $item['link']['has_children'] = 0;
          }
          $items[] = $item;
        }
        $variables = array('tree' => $items, 'trail' => $trail);
        $block['content'] = theme('jquerymenu_menu', $variables);
      }
    }

    $end = microtime(TRUE);
    $gen_time = $end - $start;
    // dsm('block took ' . $gen_time . ' ms to generate.');

    // Set the cache for all nids found. Inefficient, but that's key-value stores for you...
    foreach ($cache_nids as $nid) {
      cache_set('ct_page:nav:' . $nid, $block, 'cache_block', CACHE_TEMPORARY);
    }

    return $block;
  }

  return FALSE;
}

/**
 * Populate item children
 *
 * @param $node
 * @param $children
 *
 * @return 
 */
function _ct_page_generate_child_leaf($node, &$children) {
  if (isset($node->field_children[$node->language])) {
    if (count($node->field_children[$node->language])) {
      foreach($node->field_children[$node->language] as $child) {
        $node = node_load($child['nid']);
        $children[] = array(
          'link' => array(
            'title' => $node->title,
            'href' => 'node/' . $node->nid,
            'expanded' => 0,
          ),
          'below' => array(),
        );
        if (isset($node->field_children[$node->language])) {
          if (count($node->field_children[$node->language])) {
            foreach($node->field_children[$node->language] as $child) {
              // Get the member just created.
              $this_child = end($children);
              _ct_page_generate_child_leaf($node, $this_child['below']);
            }
          }
        }
      }
    }
    return $children;
  }
}

/**
 * Implements hook_node_presave().
 *   Ensure that nodes always use the same taxonomy term as their parent.
 *
 * @param $node
 */
function ct_page_node_presave($node) {
  if ($node->field_nav_inherit == 1) {
    // The 'save new term to child nodes' box was checked.
    // Save the new term to all decendents.
    ct_page_save_term_children($node);
  }

  if (isset($node->field_parents[$node->language])) {
    if (count($node->field_parents[$node->language])) {
      // Clear the nav block cache for this node.
      cache_clear_all('ct_page:nav:' . $nid, 'cache_block');
      /* Disabled in favor of the opt-in behavior above.
      // This node has a parent, make sure it's using the same taxonomy term as its parent.
      $parent_node = node_load($node->field_parents[$node->language][0]['nid']);
      $parent_tid = $parent_node->field_nav[$node->language][0]['tid'];
      if ($node->field_nav[$node->language][0]['tid'] != $parent_tid && isset($parent_tid)) {
        // The tids are different, update this node.
        $node->field_nav[$node->language][0]['tid'] = $parent_tid;
        drupal_set_message(t('Updated parent term for %title', array('%title' => $node->title)));
        // Update any children present as well.
        if (isset($node->field_children[$node->language])) {
          if (count($node->field_children[$node->language])) {
            foreach ($node->field_children[$node->language] as $child) {
              // All we need to do is load and save the node, this hook will take care of the rest.
              $child_node = node_load($child['nid']);
              $child_node->field_nav[$node->language][0]['tid'] = $parent_tid;
              node_save($child_node);
            }
          }
        }
      }
      */
    }
  }
  elseif (isset($node->field_children[$node->language])) {
    if (count($node->field_children[$node->language])) {
      // Clear the nav block cache for this node.
      cache_clear_all('ct_page:nav:' . $nid, 'cache_block');
    }
  }
}

/**
 * Implements hook_form_alter.
 *
 * @param $form
 * @param $form_state
 * @param $form_id
 */
function ct_page_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'page_node_form') {
    // Get weight of navigation field so we can stick our checkbox after it.
    $weight = $form['field_nav']['#weight'] + 1;
    $form['field_nav_inherit'] = array(
      '#type' => 'checkbox',
      '#title' => t('Apply to descendants'),
      '#weight' => $weight,
      '#description' => t('Check the box to apply this term to all descendant nodes.'),
    );
  }
}

/**
 * Save navigation term of given node to all children.
 *
 * @param $node
 */
function ct_page_save_term_children($node) {
  $tid = $node->field_nav[$node->language][0]['tid'];
  if (isset($node->field_children[$node->language])) {
    if (count($node->field_children[$node->language])) {
      foreach ($node->field_children[$node->language] as $child) {
        $child_node = node_load($child['nid']);
        $child_node->field_nav[$node->language][0]['tid'] = $tid;
        node_save($child_node);
        ct_page_save_term_children($child_node);
      }
    }
  }
}

/**
 * Remove section parents from orphan nodes view.
 */
function ct_page_views_pre_render(&$view) {
  if ($view->name == 'orphan_pages') {
    foreach ($view->result as $key => $result) {
      $node = node_load($result->nid);
      $term = taxonomy_term_load($node->field_nav[$node->language][0]['tid']);
      if (strcasecmp($node->title, $term->name) == 0) {
        unset($view->result[$key]);
      }
    }
  }
}

